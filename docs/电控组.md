## 电控组：（按照进程来编写，共有四个小板块，内涵部分代码，占行略多，但代码内有注释各部分的功能和设计原因）

### 环境搭建：  
- STM32CubeMX安装配置
- 开发环境搭建（Keil MDK）
- 创建基础工作框架

！*问题*：环境配置不成功，无法正常使用各个软件推进进度。

！*解决办法*：大量搜集网络资料，逐一排除操作过程中的错误，成功安装。


### 电机驱动模块：  

|1.了解L298N工作原理 |
| :------------ |
| 2. 配置PWM定时器（TIM1，2）；GPIO方向控制 |
| 3.编写电机基础控制函数  |

**以下为控制电机的代码**  

```c++
#ifndef __MOTOR_H
#define __MOTOR_H

#include "main.h"
#include "tim.h"

// 电机编号定义
typedef enum {
    MOTOR_FRONT_LEFT = 0,    // 左前电机
    MOTOR_REAR_LEFT,         // 左后电机
    MOTOR_FRONT_RIGHT,       // 右前电机
    MOTOR_REAR_RIGHT,        // 右后电机
    MOTOR_COUNT              // 电机总数
} Motor_ID;

// 电机方向定义
typedef enum {
    MOTOR_STOP = 0,          // 停止
    MOTOR_FORWARD,           // 正转
    MOTOR_BACKWARD,          // 反转
    MOTOR_BRAKE              // 刹车
} Motor_Direction;

// 电机配置结构体
typedef struct {
    TIM_HandleTypeDef* pwm_timer;    // PWM定时器
    uint32_t pwm_channel;            // PWM通道
    GPIO_TypeDef* in1_port;          // IN1端口
    uint16_t in1_pin;                // IN1引脚
    GPIO_TypeDef* in2_port;          // IN2端口
    uint16_t in2_pin;                // IN2引脚
} Motor_Config;

// 函数声明
void Motor_Init(void);
void Motor_Control(Motor_ID motor, Motor_Direction dir, uint16_t speed);
void Motor_Set_Speed(Motor_ID motor, uint16_t speed);
void Motor_Stop_All(void);
void Motor_Brake_All(void);

// 简化控制函数
void Motor_Forward(Motor_ID motor, uint16_t speed);
void Motor_Backward(Motor_ID motor, uint16_t speed);

#endif /* __MOTOR_H */```
```c++
#include "motor.h"

// 电机配置数组
static Motor_Config motors[MOTOR_COUNT];

// 电机初始化
void Motor_Init(void)
{
    /* L298N #1 配置 - 控制左轮 */
    // 左前电机
    motors[MOTOR_FRONT_LEFT].pwm_timer = &htim1;
    motors[MOTOR_FRONT_LEFT].pwm_channel = TIM_CHANNEL_1;  // ENA
    motors[MOTOR_FRONT_LEFT].in1_port = IN1_GPIO_Port;
    motors[MOTOR_FRONT_LEFT].in1_pin = IN1_Pin;           // IN1
    motors[MOTOR_FRONT_LEFT].in2_port = IN2_GPIO_Port;
    motors[MOTOR_FRONT_LEFT].in2_pin = IN2_Pin;           // IN2
    
    // 左后电机
    motors[MOTOR_REAR_LEFT].pwm_timer = &htim2;
    motors[MOTOR_REAR_LEFT].pwm_channel = TIM_CHANNEL_1;   // ENA
    motors[MOTOR_REAR_LEFT].in1_port = IN1_GPIO_Port;
    motors[MOTOR_REAR_LEFT].in1_pin = IN1_Pin;            // IN1
    motors[MOTOR_REAR_LEFT].in2_port = IN2_GPIO_Port;
    motors[MOTOR_REAR_LEFT].in2_pin = IN2_Pin;            // IN2
    
    /* L298N #2 配置 - 控制右轮 */
    // 右前电机
    motors[MOTOR_FRONT_RIGHT].pwm_timer = &htim1;
    motors[MOTOR_FRONT_RIGHT].pwm_channel = TIM_CHANNEL_2; // ENB
    motors[MOTOR_FRONT_RIGHT].in1_port = IN3_GPIO_Port;
    motors[MOTOR_FRONT_RIGHT].in1_pin = IN3_Pin;          // IN3
    motors[MOTOR_FRONT_RIGHT].in2_port = IN4_GPIO_Port;
    motors[MOTOR_FRONT_RIGHT].in2_pin = IN4_Pin;          // IN4
    
    // 右后电机
    motors[MOTOR_REAR_RIGHT].pwm_timer = &htim2;
    motors[MOTOR_REAR_RIGHT].pwm_channel = TIM_CHANNEL_2;  // ENB
    motors[MOTOR_REAR_RIGHT].in1_port = IN3_GPIO_Port;
    motors[MOTOR_REAR_RIGHT].in1_pin = IN3_Pin;           // IN3
    motors[MOTOR_REAR_RIGHT].in2_port = IN4_GPIO_Port;
    motors[MOTOR_REAR_RIGHT].in2_pin = IN4_Pin;           // IN4
    
    // 启动所有PWM通道
    for(int i = 0; i < MOTOR_COUNT; i++) {
        HAL_TIM_PWM_Start(motors[i].pwm_timer, motors[i].pwm_channel);
    }
    
    // 初始状态：停止所有电机
    Motor_Stop_All();
    
    printf("电机系统初始化完成\r\n");
}

// 控制单个电机
void Motor_Control(Motor_ID motor, Motor_Direction dir, uint16_t speed)
{
    if(motor >= MOTOR_COUNT) return;
    
    Motor_Config* m = &motors[motor];
    
    // 设置方向
    switch(dir) {
        case MOTOR_STOP:
            HAL_GPIO_WritePin(m->in1_port, m->in1_pin, GPIO_PIN_RESET);
            HAL_GPIO_WritePin(m->in2_port, m->in2_pin, GPIO_PIN_RESET);
            break;
            
        case MOTOR_FORWARD:
            HAL_GPIO_WritePin(m->in1_port, m->in1_pin, GPIO_PIN_SET);
            HAL_GPIO_WritePin(m->in2_port, m->in2_pin, GPIO_PIN_RESET);
            break;
            
        case MOTOR_BACKWARD:
            HAL_GPIO_WritePin(m->in1_port, m->in1_pin, GPIO_PIN_RESET);
            HAL_GPIO_WritePin(m->in2_port, m->in2_pin, GPIO_PIN_SET);
            break;
            
        case MOTOR_BRAKE:
            HAL_GPIO_WritePin(m->in1_port, m->in1_pin, GPIO_PIN_SET);
            HAL_GPIO_WritePin(m->in2_port, m->in2_pin, GPIO_PIN_SET);
            break;
    }
    
    // 设置速度（PWM占空比）
    __HAL_TIM_SET_COMPARE(m->pwm_timer, m->pwm_channel,speed);
}

// 仅设置电机速度（不改变方向）
void Motor_Set_Speed(Motor_ID motor, uint16_t speed)
{
    if(motor >= MOTOR_COUNT) return;
    Motor_Config* m = &motors[motor];
    __HAL_TIM_SET_COMPARE(m->pwm_timer, m->pwm_channel, speed);
}

// 停止所有电机
void Motor_Stop_All(void)
{
    for(int i = 0; i < MOTOR_COUNT; i++) {
        Motor_Control(i, MOTOR_STOP, 0);
    }
}

// 刹车所有电机
void Motor_Brake_All(void)
{
    for(int i = 0; i < MOTOR_COUNT; i++) {
        Motor_Control(i, MOTOR_BRAKE, 0);
    }
}

// 简化函数 - 电机正转
void Motor_Forward(Motor_ID motor, uint16_t speed)
{
    Motor_Control(motor, MOTOR_FORWARD, speed);
}

// 简化函数 - 电机反转
void Motor_Backward(Motor_ID motor, uint16_t speed)
{
    Motor_Control(motor, MOTOR_BACKWARD, speed);
}
```



！*问题：*无法驱动电机

！*解决办法：*改变使能引脚为高电平



#### PS2手柄集成：  
- 理解PS2通信协议
- GPIO模拟PS2时序
- 应用学长给出的配置PS2头文件源文件进行手柄数据解析

！*问题*：PS2通信始终链接不上，耗时过就，严重拖延进度。

！*解决办法*：逐行检查错误之处，一一对应代码上与实际开启引脚的差别，矫正引脚A和B的输入错误，合理布局引脚。



### 小车运动控制：  
|  学习麦轮在小车各向运动中的工作原理根据我们自己的小车情况合理布置引脚，规划不同运动状态时小车速度 |
| :------------ |
|编写控制不同运动方向的电机转发及转动功率|
|用PS2手柄上的遥杆及键位，通过摇杆推动的幅度配置车速|

**以下为小车不同运动状态时的控制代码**  

```c++
#include "mecanum_wheel.h"
#include "motor_control.h"
#include "math.h"
// 运动模式枚举
typedef enum {
    STOP = 0,
    FORWARD,
    BACKWARD, 
    LEFT,
    RIGHT,
    ROTATE_CW,    // 顺时针旋转
    ROTATE_CCW    // 逆时针旋转
} Motion_Mode;

/**
  * @brief  麦克纳姆轮运动学计算
  * @param  vx: X方向速度(-16000到16000)
  * @param  vy: Y方向速度(-16000到16000) 
  * @param  omega: 旋转速度(-12000到12000)
  * @retval 无
  */
void Mecanum_Kinematics(int32_t vx, int32_t vy, int32_t omega)
{
    // 四个轮子的速度计算
    
    
    int32_t wheel1_speed = vy + vx + omega;
    int32_t wheel2_speed = vy - vx - omega;
    int32_t wheel3_speed = vy - vx + omega; 
    int32_t wheel4_speed = vy + vx - omega;
    
    // 设置四个电机速度
    Set_Motor_Speed(0, wheel1_speed); // 左前轮
    Set_Motor_Speed(1, wheel2_speed); // 右前轮
    Set_Motor_Speed(2, wheel3_speed); // 左后轮  
    Set_Motor_Speed(3, wheel4_speed); // 右后轮
}

/**
  * @brief  PS2手柄控制小车运动
  * @param  joystick: 手柄数据结构体指针
  * @retval 无
  */
void PS2_Control_Car(JOYSTICK_TypeDef *joystick)
{
    int32_t vx = 0, vy = 0, omega = 0;
    
    // 读取左摇杆值并转换为速度(-500到500)
    // 左摇杆上下控制前后(Y方向)
    int32_t left_y = (int32_t)joystick->LJoy_UD - 128;
    // 左摇杆左右控制左右(X方向)  
    int32_t left_x = (int32_t)joystick->LJoy_LR - 128;
    
    // 读取右摇杆左右值控制旋转
    int32_t right_x = (int32_t)joystick->RJoy_LR - 128;
    
    // 设置死区，避免摇杆微小晃动
    if(abs(left_y) < 20) left_y = 0;
    if(abs(left_x) < 20) left_x = 0; 
    if(abs(right_x) < 20) right_x = 0;
    
    // 缩放速度值
    vy = left_y * 40;    // 前后速度
    vx = left_x * 40;    // 左右平移速度  
    omega = right_x * 40; //旋转速度
    
    // 调用运动学计算
    Mecanum_Kinematics(vx, vy, omega);
}```
```c++
#include "carcontral.h"

// 默认速度配置
static Speed_Config speed_config = {
    .normal_speed = 600,    // 60%速度
    .turn_speed = 400,      // 40%速度
    .spin_speed = 500       // 50%速度
};

static Car_State current_state = CAR_STOP;

// 小车控制初始化
void Car_Control_Init(void)
{
    current_state = CAR_STOP;
    Car_Stop();
    printf("小车控制系统初始化完成\r\n");
}

// 设置速度配置
void Car_Control_Set_Speed_Config(uint16_t normal, uint16_t turn, uint16_t spin)
{
    speed_config.normal_speed = normal;
    speed_config.turn_speed = turn;
    speed_config.spin_speed = spin;
}

// 小车前进
void Car_Forward(void)
{
    Motor_Forward(MOTOR_FRONT_LEFT, speed_config.normal_speed);
    Motor_Forward(MOTOR_REAR_LEFT, speed_config.normal_speed);
    Motor_Forward(MOTOR_FRONT_RIGHT, speed_config.normal_speed);
    Motor_Forward(MOTOR_REAR_RIGHT, speed_config.normal_speed);
    current_state = CAR_FORWARD;
}

// 小车后退
void Car_Backward(void)
{
    Motor_Backward(MOTOR_FRONT_LEFT, speed_config.normal_speed);
    Motor_Backward(MOTOR_REAR_LEFT, speed_config.normal_speed);
    Motor_Backward(MOTOR_FRONT_RIGHT, speed_config.normal_speed);
    Motor_Backward(MOTOR_REAR_RIGHT, speed_config.normal_speed);
    current_state = CAR_BACKWARD;
}

// 小车左转（差速转弯）
void Car_TurnLeft(void)
{
    // 左轮慢速反转，右轮快速正转
    Motor_Backward(MOTOR_FRONT_LEFT, speed_config.turn_speed / 2);
    Motor_Backward(MOTOR_REAR_LEFT, speed_config.turn_speed / 2);
    Motor_Forward(MOTOR_FRONT_RIGHT, speed_config.turn_speed);
    Motor_Forward(MOTOR_REAR_RIGHT, speed_config.turn_speed);
    current_state = CAR_TURN_LEFT;
}

// 小车右转（差速转弯）
void Car_TurnRight(void)
{
    // 左轮快速正转，右轮慢速反转
    Motor_Forward(MOTOR_FRONT_LEFT, speed_config.turn_speed);
    Motor_Forward(MOTOR_REAR_LEFT, speed_config.turn_speed);
    Motor_Backward(MOTOR_FRONT_RIGHT, speed_config.turn_speed / 2);
    Motor_Backward(MOTOR_REAR_RIGHT, speed_config.turn_speed / 2);
    current_state = CAR_TURN_RIGHT;
}

// 小车原地左转
void Car_SpinLeft(void)
{
    // 左轮反转，右轮正转
    Motor_Backward(MOTOR_FRONT_LEFT, speed_config.spin_speed);
    Motor_Backward(MOTOR_REAR_LEFT, speed_config.spin_speed);
    Motor_Forward(MOTOR_FRONT_RIGHT, speed_config.spin_speed);
    Motor_Forward(MOTOR_REAR_RIGHT, speed_config.spin_speed);
    current_state = CAR_SPIN_LEFT;
}

// 小车原地右转
void Car_SpinRight(void)
{
    // 左轮正转，右轮反转
    Motor_Forward(MOTOR_FRONT_LEFT, speed_config.spin_speed);
    Motor_Forward(MOTOR_REAR_LEFT, speed_config.spin_speed);
    Motor_Backward(MOTOR_FRONT_RIGHT, speed_config.spin_speed);
    Motor_Backward(MOTOR_REAR_RIGHT, speed_config.spin_speed);
    current_state = CAR_SPIN_RIGHT;
}

// 小车停止
void Car_Stop(void)
{
    Motor_Stop_All();
    current_state = CAR_STOP;
}

// 小车刹车
void Car_Brake(void)
{
    Motor_Brake_All();
    current_state = CAR_STOP;
}

// 带速度控制的运动函数
void Car_Move_With_Speed(Car_State state, uint16_t speed)
{
    switch(state) {
        case CAR_FORWARD:
            Motor_Forward(MOTOR_FRONT_LEFT, speed);
            Motor_Forward(MOTOR_REAR_LEFT, speed);
            Motor_Forward(MOTOR_FRONT_RIGHT, speed);
            Motor_Forward(MOTOR_REAR_RIGHT, speed);
            break;
            
        case CAR_BACKWARD:
            Motor_Backward(MOTOR_FRONT_LEFT, speed);
            Motor_Backward(MOTOR_REAR_LEFT, speed);
            Motor_Backward(MOTOR_FRONT_RIGHT, speed);
            Motor_Backward(MOTOR_REAR_RIGHT, speed);
            break;
            
        default:
            break;
    }
    current_state = state;
}

// 差速转向（高级控制）
void Car_Differential_Turn(int16_t left_speed, int16_t right_speed)
{
    // 左轮控制
    if(left_speed >= 0) {
        Motor_Forward(MOTOR_FRONT_LEFT, left_speed);
        Motor_Forward(MOTOR_REAR_LEFT, left_speed);
    } else {
        Motor_Backward(MOTOR_FRONT_LEFT, -left_speed);
        Motor_Backward(MOTOR_REAR_LEFT, -left_speed);
    }
    
    // 右轮控制
    if(right_speed >= 0) {
        Motor_Forward(MOTOR_FRONT_RIGHT, right_speed);
        Motor_Forward(MOTOR_REAR_RIGHT, right_speed);
    } else {
        Motor_Backward(MOTOR_FRONT_RIGHT, -right_speed);
        Motor_Backward(MOTOR_REAR_RIGHT, -right_speed);
    }
    
    current_state = CAR_TURN_LEFT; // 简化状态
}

// 获取当前状态
Car_State Car_Get_Current_State(void)
{
    return current_state;
} ```  



~~这里只引用了几个代码，全部写上太长~~